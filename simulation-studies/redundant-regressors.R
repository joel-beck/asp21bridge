pacman::p_load(dplyr, ggplot2, purrr, tidyr)
library(asp21bridge)


### . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ..
### Functions to generate data                                              ####

create_pairs <- function(n, rho) {
  mvtnorm::rmvnorm(n = n, mean = c(0, 0), sigma = matrix(data = c(1, rho, rho, 1), nrow = 2))
}

create_design_matrix <- function(n, rho, pairs) {
  X <- map(.x = 1:pairs, .f = ~ create_pairs(n = n, rho = rho)) %>%
    do.call(what = cbind, args = .) %>%
    magrittr::set_colnames(paste0("X", 1:(2 * pairs))) %>%
    as_tibble()

  # standardized covariates
  X_stand <- X %>%
    mutate(across(.cols = everything(), .fns = ~ (.x - mean(.x)) / sd(.x)))

  return(list(X = X, X_stand = X_stand))
}

create_data <- function(n, rho, pairs) {
  l <- create_design_matrix(n = n, rho = rho, pairs = pairs)
  X <- l$X
  Z <- X %>% select(X1, X3)

  beta <- rep(c(1, 0), times = pairs)
  gamma <- c(1, 1)

  y <- vector(mode = "numeric", length = n)

  # generate y with unstandardized data
  for (i in seq_along(y)) {
    mu <- sum(X[i, ] * beta)
    sigma <- exp(sum(Z[i, ] * gamma))
    y[i] <- rnorm(n = 1, mean = mu, sd = sigma)
  }

  X_stand <- l$X_stand
  Z_stand <- X_stand %>% select(X1, X3)
  y_stand <- vector(mode = "numeric", length = n)

  # generate y with standardized data
  for (i in seq_along(y)) {
    mu <- sum(X_stand[i, ] * beta)
    sigma <- exp(sum(Z_stand[i, ] * gamma))
    y_stand[i] <- rnorm(n = 1, mean = mu, sd = sigma)
  }

  return(tibble(y = y, y_stand = y_stand) %>% bind_cols(X_stand))
}

# fit lmls(), mcmc() and mcmc_ridge() to standardized covariates

# with y generated by unstandardized covariates
create_fit <- function(df, num_sim) {
  lmls(location = y ~ . - y_stand, scale = ~ X1 + X3, data = df, light = FALSE) %>%
    mcmc(nsim = num_sim) %>%
    mcmc_ridge(num_sim = num_sim)
}

# with y generated by standardized covariates
create_fit_stand <- function(df, num_sim) {
  lmls(location = y_stand ~ . - y, scale = ~ X1 + X3, data = df, light = FALSE) %>%
    mcmc(nsim = num_sim) %>%
    mcmc_ridge(num_sim = num_sim)
}


# helper function to combine estimates from all three models into single tibble
bind_results <- function(fit, pairs) {
  mcmc_ridge_res <- summary_complete(fit) %>%
    filter(stringr::str_detect(string = Parameter, pattern = "beta")) %>%
    select(Parameter, `Posterior Mean`) %>%
    mutate(sort_helper = readr::parse_number(Parameter)) %>%
    arrange(sort_helper)

  mcmc_res <- summary_complete(fit$mcmc) %>%
    slice(1:21) %>%
    mutate(sort_helper = if_else(condition = Parameter == "(Intercept)",
      true = 0, false = readr::parse_number(Parameter)
    )) %>%
    arrange(sort_helper) %>%
    pull(`Posterior Mean`)

  lmls_res <- coef(fit)$location

  tibble(
    Parameter = mcmc_ridge_res %>% pull(Parameter),
    mcmc_ridge = mcmc_ridge_res %>% pull(`Posterior Mean`),
    mcmc = mcmc_res,
    lmls = lmls_res,
    truth = c(0, rep(c(1, 0), times = pairs))
  )
}

create_plot_data <- function(complete_results) {
  complete_results %>%
    mutate(Parameter = stringr::str_replace(
      string = Parameter, pattern = "_(.*)", replacement = "[\\1]"
    )) %>%
    mutate(Parameter = factor(Parameter) %>% forcats::fct_inorder() %>%
      forcats::fct_rev()) %>%
    mutate(truth = factor(truth)) %>%
    pivot_longer(cols = mcmc_ridge:lmls)
}

create_plot <- function(plot_data) {
  plot_data %>%
    ggplot(mapping = aes(x = value, y = Parameter, color = truth)) +
    geom_vline(xintercept = 1, color = "#2CA02CFF", linetype = "dashed") +
    geom_vline(xintercept = 0, color = "#CB2314FF", linetype = "dashed") +
    geom_point() +
    geom_segment(mapping = aes(xend = 0, yend = Parameter)) +
    facet_wrap(facets = vars(name)) +
    labs(
      x = "Coefficient Estimates", y = NULL,
      title = "Posterior Means / MLE for pairwise correlated Covariates",
      color = "True Coefficient Value:"
    ) +
    scale_x_continuous(breaks = scales::breaks_pretty()) +
    scale_y_discrete(
      labels = parse(text = levels(plot_data$Parameter))
    ) +
    scale_color_manual(values = c("0" = "#CB2314FF", "1" = "#2CA02CFF")) +
    theme_light(base_size = 9) +
    theme(
      legend.position = "top",
      plot.title = element_text(hjust = 0.5)
    )
}

# sum of squared coefficient values (squared 2-norm) for each model and true coefficient value
calc_coef_norms <- function(complete_results) {
  complete_results %>%
    pivot_longer(cols = mcmc_ridge:lmls, names_to = "model") %>%
    mutate(abs_value = abs(value)) %>%
    group_by(model, truth) %>%
    summarise(coefficient_norm = sum(value^2)) %>%
    mutate(truth = if_else(truth == 0, "truth = 0", "truth = 1")) %>%
    pivot_wider(names_from = truth, values_from = coefficient_norm)
}


### . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ..
### Actual Data Generation                                                  ####

set.seed(1234)
n <- 50
rho <- 0.9
pairs <- 10
num_sim <- 10000

df <- create_data(n = n, rho = rho, pairs = pairs)

fit <- create_fit(df = df, num_sim = num_sim)
complete_results <- bind_results(fit = fit, pairs = pairs)
coef_norms <- calc_coef_norms(complete_results = complete_results)
plot_data <- create_plot_data(complete_results = complete_results)
plot <- create_plot(plot_data = plot_data)

fit_stand <- create_fit_stand(df = df, num_sim = num_sim)
complete_results_stand <- bind_results(fit = fit_stand, pairs = pairs)
coef_norms_stand <- calc_coef_norms(complete_results = complete_results_stand)
plot_data_stand <- create_plot_data(complete_results = complete_results_stand)
plot_stand <- create_plot(plot_data = plot_data_stand)


readr::write_rds(
  x = list(
    coef_norms = coef_norms,
    plot = plot,
    coef_norms_stand = coef_norms_stand,
    plot_stand = plot_stand
  ),
  file = here::here("simulation-studies", "redundant-regressors.rds")
)
