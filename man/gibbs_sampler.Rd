% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gibbs_sampler.R
\name{gibbs_sampler}
\alias{gibbs_sampler}
\title{Gibbs sampling algorithm}
\usage{
gibbs_sampler(
  m = NULL,
  X = NULL,
  Z = NULL,
  y = NULL,
  num_sim = 1000,
  beta_start = NULL,
  gamma_start = NULL,
  tau_start = 1,
  xi_start = 1,
  a_tau = 1,
  b_tau = 3,
  a_xi = 1,
  b_xi = 3,
  prop_var_scale = 3,
  mh_location = FALSE,
  prop_var_loc = 1
)
}
\arguments{
\item{m}{Model object containing a beta and gamma predictor, as well as the according
model matrices. The model is used in second stage, if one of \code{X}, \code{Z}, \code{y},
\code{beta_start} or \code{gamma_start} is not given, \cr
Default: NULL}

\item{X}{Matrix containing the data according to the beta_start coefficient, \cr
Default: NULL}

\item{Z}{Matrix containing the data according to the gamma_start coefficient, \cr
Default: NULL}

\item{y}{Response vector; \code{y = X * beta + Z * gamma},
Default: NULL}

\item{num_sim}{Number of simulations, \cr
Default: 1000}

\item{beta_start}{Starting vector for simulation, where \code{beta} is a linear predictor
for the mean (= the location), that is normally distributed, \cr
Default: NULL}

\item{gamma_start}{Starting vector for simulation, where \code{gamma} is a linear predictor
for the standard deviation (= the scale), that is normally
distributed, \cr
Default: NULL}

\item{tau_start}{Starting value for the variance of the normal distribution of the beta
parameter, where \code{tau_start} is inverse gamma (IG) distributed.
Regularization parameter in a Bayesian ridge setting, \cr
Default: 1}

\item{xi_start}{Starting value for the variance of the normal distribution of the gamma
parameter, where \code{xi_start} is inverse gamma (IG) distributed.
Regularization parameter in a Bayesian ridge setting, \cr
Default: 1}

\item{a_tau}{Fix shape parameter of the IG distribution of \code{tau_start}, \cr
Default: 1}

\item{b_tau}{Fix scale parameter of the IG distribution of \code{tau_start}, \cr
Default: 3}

\item{a_xi}{Fix shape parameter of the IG distribution of \code{xi_start}, \cr
Default: 1}

\item{b_xi}{Fix scale parameter of the IG distribution of \code{xi_start}, \cr
Default: 3}

\item{prop_var_scale}{Variance of proposal distribution for \code{gamma} sampling, \cr
Default: 3}

\item{mh_location}{If TRUE, location parameter is sampled with
Metropolis - Hastings Algorithm, \cr
Default: FALSE}

\item{prop_var_loc}{Variance of proposal distribution for \code{beta} sampling, \cr
Default: 1}
}
\value{
Depending on the input structure, different output types are available.
In each case a a Markov Chain of samples for the parameters is generated. \cr
If matrices and parameters are only assigned by hand, a list containing the
parameters with their according iterations is available via the \code{print()}
command. \cr
In case a model object is used at any stage, the output extends the model by
the same list, that can be obtained via \code{model$mcmc_ridge} or outputs the last
iteration as model parameters via \verb{summary(model, type = "mcmc_ridge)}. \cr
In both cases the package comes with the \code{summary_complete(model)} function,
which gives additional information about the Markov Chain's results. For more
see \code{?summary_complete()}.
}
\description{
The \code{gibbs_sampler()} function is a Markov chain Monte Carlo (MCMC)
algorithm allowing to simulate from parameters of a location scale
regression model or from matrices and parameters that are assigned by
hand. \cr
The function is primarily used in a Bayesian setting, where
ridge-regularization can be obtained through the variance of the
corresponding prior distributions.
}
\examples{
# Gibbs sampling with lslm model input.
# Output extends model by Ridge-part.
fit <- lslm(
  location = y ~ x1 + x2 + z1 + z2, scale = ~ z1 + z2,
  data = toy_data, light = FALSE
)
fit <- gibbs_sampler(
  m = fit,
  num_sim = 1000
)
summary(fit, type = "mcmc_ridge")
summary_complete(fit)

# Gibbs sampling with input by hand.
# Outputs list with each parameter and iteration.
beta <- c(2, -4, 5, 1)
gamma <- c(0.003, 0.002)
fit <- gibbs_sampler(
  X = cbind(toy_data$x1, toy_data$x2, toy_data$z1, toy_data$z2),
  Z = cbind(toy_data$z1, toy_data$z2),
  y = toy_data$y,
  beta_start = beta, gamma_start = gamma,
  tau_start = 3, xi_start = 0.5,
  prop_var_scale = 2.3
)
print(fit)
summary_complete(fit)

# Gibbs sampling with mixed input. The function uses matrices assigned by
# hand on first stage and takes missing parameters out of the model.
# Output extends model by Ridge-part, since model objects were used.
gamma <- c(0.003, 0.002)
fit <- lslm(
  location = y ~ x1 + x2 + z1 + z2, scale = ~ z1 + z2,
  data = toy_data, light = FALSE
)
fit <- gibbs_sampler(
  m = fit,
  Z = cbind(toy_data$z1, toy_data$z2),
  gamma_start = gamma,
  num_sim = 1000
)
summary(fit, type = "mcmc_ridge")
summary_complete(fit)
}
