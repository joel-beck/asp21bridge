#   ____________________________________________________________________________
#   Helper Functions                                                        ####

#' @importFrom rlang .data

collect_results <- function(samples, include_plot = FALSE) {
  full_data <- samples %>%
    as.data.frame() %>%
    tidyr::pivot_longer(
      cols = dplyr::everything(), names_to = "Parameter", values_to = "values"
    ) %>%
    dplyr::nest_by(.data$Parameter, .key = "Data") %>%
    dplyr::mutate(
      "5% Quantile" = stats::quantile(.data$Data$values, probs = 0.05),
      "Posterior Mean" = mean(.data$Data$values),
      "Posterior Median" = stats::median(.data$Data$values),
      "95% Quantile" = stats::quantile(.data$Data$values, probs = 0.95),
      "Standard Deviation" = stats::sd(.data$Data$values)
    )

  full_data <- full_data %>%
    dplyr::ungroup() %>%
    dplyr::mutate(Data = purrr::map2(
      .x = .data$Data, .y = .data$Parameter,
      .f = ~ dplyr::rename_at(.tbl = .x, .vars = 1, .funs = function(z) paste0(.y, ""))
    ))

  if (include_plot) {
    full_data <- full_data %>%
      dplyr::rowwise() %>%
      dplyr::mutate(Plot = list(diagnostic_plots(
        samples = .data$Data, lag_max = 30, robust = TRUE, latex = TRUE
      )))
  }

  output <- full_data %>%
    dplyr::ungroup() %>%
    dplyr::select(-.data$Data)

  # drop Parameter column, if Input is numeric vector
  if (is.vector(samples, mode = "numeric")) {
    output <- output %>%
      dplyr::select(-.data$Parameter)
  }

  # if no column names of input matrix are provided
  if (is.matrix(samples) && is.null(colnames(samples))) {
    output$Parameter <- paste("col", 1:nrow(output), sep = "_")
  }

  return(output)
}


#   ____________________________________________________________________________
#   Main Function                                                           ####

#' @title Display and access results of Markov Chain Monte Carlo sampling
#'
#' @description The `summary_complete()` function calculates summary statistics
#'              of the posterior samples for all coefficients included in the
#'              model. The output is collected in a single data frame enabling a
#'              convenient analysis with common data frame filtering and
#'              manipulation methods. \cr
#'              In contrast to the generic `summary()` function, which primarily
#'              serves as an informative visual display, each entry of the data
#'              frame output can be easily accessed and saved in a variable.
#'
#' @param samples Model object of the class 'lslm', list, matrix or numeric
#'                vector containing samples of the MCMC sampler.
#'
#' @param include_plot If TRUE, an additional column containing diagnostic plots
#'                     for the posterior samples of the corresponding coefficient
#'                     is added. This option allows for easy access to visual
#'                     confirmation of the numerical results during a data
#'                     frame manipulation workflow. \cr
#'                     Plots are generated by the `diagnostic_plots()` function
#'                     with chosen parameter values `lag_max = 30`,
#'                     `robust = TRUE` and `latex = TRUE`. \cr
#'                     Default: FALSE
#'
#' @return A tibble with one row for each coefficient and one column for each
#'         summary statistic.
#'
#' @examples
#' fit <- lslm(
#'   location = y ~ x1 + x2 + z1 + z2, scale = ~ z1 + z2,
#'   data = toy_data, light = FALSE
#' ) %>%
#'   gibbs_sampler(num_sim = 1000)
#'
#' # list of 4 matrices with 1000 rows each
#' samples <- fit$mcmc_ridge$sampling_matrices
#'
#' # model input
#' summary_complete(fit)
#'
#' # list input
#' summary_complete(samples)
#'
#' # matrix input
#' summary_complete(samples$location)
#'
#' # numeric vector input
#' summary_complete(samples$location[, 2])
#'
#' # keep 'Parameter' column with single column matrix
#' summary_complete(samples$location[, 2, drop = FALSE])
#'
#' # extract diagnostic plot during data frame analysis
#' summary_complete(fit, include_plot = TRUE) %>%
#'   dplyr::filter(Parameter == "beta_1") %>%
#'   dplyr::pull(Plot)
#'
#' @export

summary_complete <- function(samples, include_plot = FALSE) {
  if (is.matrix(samples) || is.vector(samples, mode = "numeric")) {
    # if input is a matrix or a numeric vector
    collect_results(samples = samples, include_plot = include_plot)
  } else if (class(samples) == "lslm") {
    # if input is model object
    purrr::map_dfr(
      .x = samples$mcmc_ridge[[1]], .f = collect_results,
      include_plot = include_plot
    )
  } else if (is.list(samples)) {
    # if input is a list but not a model object
    if (any(names(samples) == "sampling_matrices")) {
      # if input is gibbs_sampler() output in list format with two entries
      purrr::map_dfr(
        .x = samples[["sampling_matrices"]],
        .f = collect_results, include_plot = include_plot
      )
    } else {
      # if input is list with just the sampling matrices
      purrr::map_dfr(
        .x = samples,
        .f = collect_results, include_plot = include_plot
      )
    }
  } else {
    stop(paste(
      "Input 'samples' must be a model object of the class 'lslm',",
      "a numeric vector or matrix or a list of vectors and matrices!"
    ))
  }
}
